<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>입자 클라우드 비주얼라이저</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 8px;
    }
    label, select, input { color: white; display: block; margin-top: 5px; }
    select {
      background-color: #333;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="shape">모양 선택:</label>
    <select id="shape">
      <option value="sphere">구</option>
      <option value="cube">큐브</option>
      <option value="cylinder">원기둥</option>
      <option value="cone">원뿔</option>
      <option value="plane">평면</option>
      <option value="tube">사각파이프</option>
      <option value="random">랜덤</option>
    </select>

    <label for="color">색상 선택:</label>
    <input type="color" id="color" value="#ffffff">

    <label for="particleSize">입자 크기:</label>
    <input type="range" id="particleSize" min="0.01" max="1" step="0.01" value="0.1">

    <label for="rotationSpeed">회전 속도:</label>
    <input type="range" id="rotationSpeed" min="0" max="0.05" step="0.001" value="0.002">

    <label>
      <input type="checkbox" id="autoRotate" checked>
      자동 회전
    </label>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const particleCount = 1000;
    const geometry = new THREE.BufferGeometry();
    let positions = new Float32Array(particleCount * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
    camera.position.z = 10;

    let rotationSpeed = 0.002;
    let autoRotate = true;

    function generatePositions(shape) {
      const pos = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        switch (shape) {
          case 'cube':
            pos[i3] = (Math.random() - 0.5) * 10;
            pos[i3 + 1] = (Math.random() - 0.5) * 10;
            pos[i3 + 2] = (Math.random() - 0.5) * 10;
            break;
          case 'cylinder': {
            const angle = Math.random() * 2 * Math.PI;
            const radius = 5;
            pos[i3] = Math.cos(angle) * radius;
            pos[i3 + 1] = (Math.random() - 0.5) * 10;
            pos[i3 + 2] = Math.sin(angle) * radius;
            break;
          }
          case 'cone': {
            const angle = Math.random() * 2 * Math.PI;
            const h = Math.random() * 10;
            const r = (10 - h) / 2;
            pos[i3] = Math.cos(angle) * r;
            pos[i3 + 1] = h - 5;
            pos[i3 + 2] = Math.sin(angle) * r;
            break;
          }
          case 'plane':
            pos[i3] = (Math.random() - 0.5) * 10;
            pos[i3 + 1] = (Math.random() - 0.5) * 0.1;
            pos[i3 + 2] = (Math.random() - 0.5) * 10;
            break;
          case 'tube':
            pos[i3] = (Math.random() - 0.5) * 10;
            pos[i3 + 1] = (Math.random() - 0.5) * 10;
            pos[i3 + 2] = (Math.random() < 0.5 ? -5 : 5);
            break;
          case 'random':
            pos[i3] = Math.random() * 20 - 10;
            pos[i3 + 1] = Math.random() * 20 - 10;
            pos[i3 + 2] = Math.random() * 20 - 10;
            break;
          case 'sphere':
          default: {
            const phi = Math.random() * 2 * Math.PI;
            const costheta = Math.random() * 2 - 1;
            const theta = Math.acos(costheta);
            const r = 5;
            pos[i3] = r * Math.sin(theta) * Math.cos(phi);
            pos[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            pos[i3 + 2] = r * Math.cos(theta);
          }
        }
      }
      return pos;
    }

    function changeShape(shape) {
      const newPositions = generatePositions(shape);
      const positionAttr = geometry.attributes.position;

      // 실제 좌표 배열 값을 anime가 인식하도록 복사
      const current = positionAttr.array.slice();
      anime({
        targets: current,
        easing: 'easeInOutQuad',
        duration: 1000,
        update: () => {
          for (let i = 0; i < current.length; i++) {
            positionAttr.array[i] += (newPositions[i] - positionAttr.array[i]) * 0.05;
          }
          positionAttr.needsUpdate = true;
        }
      });
    }

    // 초기화
    positions = generatePositions('sphere');
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    function animate() {
      requestAnimationFrame(animate);
      if (autoRotate) {
        particles.rotation.y += rotationSpeed;
        particles.rotation.x += rotationSpeed / 2;
      }
      renderer.render(scene, camera);
    }
    animate();

    // 이벤트 핸들링
    document.getElementById('shape').addEventListener('change', (e) => {
      changeShape(e.target.value);
    });

    document.getElementById('color').addEventListener('input', (e) => {
      material.color.set(e.target.value);
    });

    document.getElementById('particleSize').addEventListener('input', (e) => {
      material.size = parseFloat(e.target.value);
    });

    document.getElementById('rotationSpeed').addEventListener('input', (e) => {
      rotationSpeed = parseFloat(e.target.value);
    });

    document.getElementById('autoRotate').addEventListener('change', (e) => {
      autoRotate = e.target.checked;
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
